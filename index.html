<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D FPS Shooter - Multiplayer</title>
<style>
  body { margin:0; overflow:hidden; font-family:Arial, sans-serif; }
  #ui {
    position: absolute; top: 10px; left: 10px; color: white; font-size: 20px; pointer-events: none;
    text-shadow: 1px 1px 3px black;
  }
  #crosshair {
    position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
    margin: -10px 0 0 -10px; color: white; font-size: 30px; pointer-events: none;
  }
  #menu {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.8); color: white; display: flex;
    flex-direction: column; justify-content: center; align-items: center;
  }
  button {
    padding: 15px 30px; font-size: 20px; margin: 10px; cursor: pointer;
  }
</style>
</head>
<body>

<div id="ui">Health: <span id="health">100</span> | Score: <span id="score">0</span></div>
<div id="crosshair">+</div>

<div id="menu">
  <h1>3D FPS Shooter</h1>
  <p>Controls: WASD to move, Mouse to look, Click to shoot</p>
  <button id="singleplayer">Singleplayer</button>
  <button id="host">Host Multiplayer Game</button>
  <button id="join">Join Multiplayer Game</button>
  <input id="peerId" placeholder="Enter host Peer ID" style="padding:10px; font-size:16px; margin-top:20px;">
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.167.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.167.1/examples/js/controls/PointerLockControls.js"></script>
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

<script>
// --------------------- Scene Setup ---------------------
let camera, scene, renderer, controls;
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();
let prevTime = performance.now();

const enemies = [];
const bullets = [];
const playerBullets = [];
let health = 100;
let score = 0;
let gameActive = false;

const peer = new Peer(); // PeerJS instance
let conn = null; // connection to other player(s)
let players = {}; // other players in multiplayer

init();
animate();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);
  scene.fog = new THREE.Fog(0x87ceeb, 10, 100);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.y = 1.6;

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  controls = new THREE.PointerLockControls(camera, document.body);
  document.body.addEventListener('click', () => controls.lock());

  // Floor
  const floorGeo = new THREE.PlaneGeometry(200, 200);
  const floorMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

  // Walls
  const wallGeo = new THREE.BoxGeometry(200, 10, 2);
  const wallMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
  const wall1 = new THREE.Mesh(wallGeo, wallMat);
  wall1.position.set(0, 5, -100);
  scene.add(wall1);

  const wall2 = new THREE.Mesh(wallGeo, wallMat);
  wall2.position.set(0, 5, 100);
  scene.add(wall2);

  const wall3 = new THREE.Mesh(wallGeo, wallMat);
  wall3.rotation.y = Math.PI / 2;
  wall3.position.set(-100, 5, 0);
  scene.add(wall3);

  const wall4 = new THREE.Mesh(wallGeo, wallMat);
  wall4.rotation.y = Math.PI / 2;
  wall4.position.set(100, 5, 0);
  scene.add(wall4);

  // Lights
  const ambient = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambient);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(50, 50, 50);
  dirLight.castShadow = true;
  scene.add(dirLight);

  // Spawn enemies
  for (let i = 0; i < 8; i++) {
    spawnEnemy();
  }

  // Shooting
  document.addEventListener('mousedown', shoot);

  // Movement keys
  document.addEventListener('keydown', onKeyDown);
  document.addEventListener('keyup', onKeyUp);

  // UI buttons
  document.getElementById('singleplayer').onclick = () => startGame(false);
  document.getElementById('host').onclick = () => startGame(true);
  document.getElementById('join').onclick = () => {
    const hostId = document.getElementById('peerId').value;
    if (hostId) joinGame(hostId);
  };

  // PeerJS events
  peer.on('open', id => console.log('My Peer ID:', id));
  peer.on('connection', c => {
    conn = c;
    conn.on('data', data => {
      if (data.type === 'playerPos') {
        if (!players[data.id]) {
          players[data.id] = createPlayerModel(data.id);
          scene.add(players[data.id]);
        }
        players[data.id].position.set(data.x, data.y, data.z);
        players[data.id].rotation.y = data.rotationY;
      } else if (data.type === 'bullet') {
        createBullet(data.x, data.y, data.z, data.dx, data.dy, data.dz, true);
      }
    });
  });

  window.addEventListener('resize', onWindowResize);
}

function startGame(isMultiplayer) {
  document.getElementById('menu').style.display = 'none';
  gameActive = true;
  controls.lock();
  if (isMultiplayer) {
    console.log('Waiting for players... Your Peer ID: ' + peer.id);
  }
}

function joinGame(hostId) {
  conn = peer.connect(hostId);
  conn.on('open', () => {
    document.getElementById('menu').style.display = 'none';
    gameActive = true;
    controls.lock();
    console.log('Connected to host!');
  });
}

function spawnEnemy() {
  const geometry = new THREE.BoxGeometry(2, 4, 2);
  const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
  const enemy = new THREE.Mesh(geometry, material);
  enemy.position.set(
    Math.random() * 80 - 40,
    2,
    Math.random() * 80 - 40
  );
  enemy.userData = { health: 3, speed: 0.02 + Math.random() * 0.01 };
  scene.add(enemy);
  enemies.push(enemy);
}

function createPlayerModel(id) {
  const geometry = new THREE.BoxGeometry(1.5, 3, 1.5);
  const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.y = 1.5;
  mesh.userData = { id };
  return mesh;
}

function shoot() {
  if (!controls.isLocked || !gameActive) return;

  const direction = new THREE.Vector3();
  camera.getWorldDirection(direction);

  const bullet = new THREE.Mesh(
    new THREE.SphereGeometry(0.2),
    new THREE.MeshBasicMaterial({ color: 0xffff00 })
  );
  bullet.position.copy(camera.position);
  bullet.velocity = direction.clone().multiplyScalar(1.5);

  scene.add(bullet);
  playerBullets.push(bullet);

  // Send bullet to other players if multiplayer
  if (conn && conn.open) {
    conn.send({
      type: 'bullet',
      x: bullet.position.x, y: bullet.position.y, z: bullet.position.z,
      dx: bullet.velocity.x, dy: bullet.velocity.y, dz: bullet.velocity.z
    });
  }
}

function createBullet(x, y, z, dx, dy, dz, isOtherPlayer = false) {
  const bullet = new THREE.Mesh(
    new THREE.SphereGeometry(0.2),
    new THREE.MeshBasicMaterial({ color: isOtherPlayer ? 0x00ffff : 0xffff00 })
  );
  bullet.position.set(x, y, z);
  bullet.velocity = new THREE.Vector3(dx, dy, dz);
  scene.add(bullet);
  bullets.push(bullet);
}

function onKeyDown(event) {
  switch (event.code) {
    case 'KeyW': moveForward = true; break;
    case 'KeyS': moveBackward = true; break;
    case 'KeyA': moveLeft = true; break;
    case 'KeyD': moveRight = true; break;
  }
}

function onKeyUp(event) {
  switch (event.code) {
    case 'KeyW': moveForward = false; break;
    case 'KeyS': moveBackward = false; break;
    case 'KeyA': moveLeft = false; break;
    case 'KeyD': moveRight = false; break;
  }
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);

  const time = performance.now();
  const delta = (time - prevTime) / 1000;
  prevTime = time;

  if (controls.isLocked && gameActive) {
    velocity.x -= velocity.x * 10.0 * delta;
    velocity.z -= velocity.z * 10.0 * delta;

    direction.z = Number(moveForward) - Number(moveBackward);
    direction.x = Number(moveRight) - Number(moveLeft);
    direction.normalize();

    if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
    if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

    controls.moveRight(-velocity.x * delta);
    controls.moveForward(-velocity.z * delta);

    // Send position to other players
    if (conn && conn.open) {
      conn.send({
        type: 'playerPos',
        id: peer.id,
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z,
        rotationY: camera.rotation.y
      });
    }

    // Update player bullets
    for (let i = playerBullets.length - 1; i >= 0; i--) {
      const b = playerBullets[i];
      b.position.add(b.velocity.clone().multiplyScalar(delta * 60));

      // Hit detection
      for (let j = enemies.length - 1; j >= 0; j--) {
        const e = enemies[j];
        if (b.position.distanceTo(e.position) < 2) {
          e.userData.health--;
          scene.remove(b);
          playerBullets.splice(i, 1);
          if (e.userData.health <= 0) {
            scene.remove(e);
            enemies.splice(j, 1);
            score += 10;
            document.getElementById('score').textContent = score;
            if (enemies.length < 5) spawnEnemy();
          }
          break;
        }
      }

      if (b.position.length() > 200) {
        scene.remove(b);
        playerBullets.splice(i, 1);
      }
    }

    // Update enemy bullets (if any)
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.position.add(b.velocity.clone().multiplyScalar(delta * 60));

      if (b.position.distanceTo(camera.position) < 2) {
        health -= 10;
        document.getElementById('health').textContent = health;
        scene.remove(b);
        bullets.splice(i, 1);
        if (health <= 0) {
          alert('Game Over! Final Score: ' + score);
          location.reload();
        }
      }
    }

    // Enemy AI
    enemies.forEach(enemy => {
      const dir = new THREE.Vector3();
      dir.subVectors(camera.position, enemy.position).normalize();
      enemy.position.add(dir.multiplyScalar(enemy.userData.speed));

      // Enemy shoots occasionally
      if (Math.random() < 0.005) {
        const bulletDir = new THREE.Vector3();
        bulletDir.subVectors(camera.position, enemy.position).normalize();
        createBullet(enemy.position.x, enemy.position.y + 2, enemy.position.z,
                     bulletDir.x * 0.5, bulletDir.y * 0.5, bulletDir.z * 0.5);
      }
    });
  }

  renderer.render(scene, camera);
}
</script>
</body>
</html>
